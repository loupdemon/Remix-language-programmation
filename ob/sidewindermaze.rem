Draw a sidewinder  maze and solve it.
This version uses objects.
	- sidewindermaze.rem
	- Robert Sheehan
	- 27/06/21

randomize

SIZE : 10

square : make shape of {
	{-1, -1}, {-1, 1}, {1, 1}, {1, -1}
} with size (SIZE)

LEFT : 1
RIGHT : 2
UP : 3
DOWN : 4

num-rows : 28
num-cols : 38

the-maze : {}
start : {1, 1} ; {random 39, random 29}
finish : find the middle

create a maze cell at (the-row) and (the-col) :
	create
		row : the-row
		column : the-col
		right-open : false
		bottom-open : false
		distance : -1
		centre : {
			centre-x + ((2 × the-col) - (num-cols + 1)) × SIZE,
			centre-y + ((2 × the-row) - (num-rows + 1)) × SIZE
		}

		remove the right wall in the () :
			right-open : true

		remove the bottom wall in the () :
			bottom-open : true

		draw the () :
			draw with (red) pen
			draw (square) at (centre)

		draw the exits on the () :
			draw with (black) pen
			if (right-open)
				x : centre [1] + SIZE
				y : centre [2] - SIZE
				start : { x, y }
				y : centre [2] + SIZE
				finish : { x, y }
				draw line from (start) to (finish)
			if (bottom-open)
				x : centre [1] - SIZE
				y : centre [2] + SIZE
				start : { x, y }
				x : centre[1] + SIZE
				finish : { x, y }
				draw line from (start) to (finish)

		(colour) dot in the () :
			fill colour (colour)
			draw circle of (SIZE ÷ 2) at (centre)

		right from the () :
			cell at { column + 1, row }

		left from the () :
			cell at { column - 1, row}

		up from the () :
			cell at { column, row - 1 }

		down from the () :
			cell at { column, row + 1 }

		can move right from the () :
			right-open

		can move left from the () :
			if (column = 1)
				return false
			left-cell : cell at { column - 1, row }
			can move right from the (left-cell)

		can move down from the () :
			bottom-open

		can move up from the () :
			if (row = 1)
				return false
			up-cell : cell at { column, row - 1}
			can move down from the (up-cell)

		not visited () :
			distance = -1

		() is (new-distance) away :
			distance = new-distance

		move outwards from the () :
			new-distance : distance + 1
			if all of {
				[can move right from the ()],
				[not visited (right from the ())]
			}
				move (RIGHT) from () with (new-distance)
			if all of {
				[can move down from the ()],
				[not visited (down from the ())]
			}
				move (DOWN) from () with (new-distance)
			if all of {
				[can move left from the ()],
				[not visited (left from the ())]
			}
				move (LEFT) from () with (new-distance)
			if all of {
				[can move up from the ()],
				[not visited (up from the ())]
			}
				move (UP) from () with (new-distance)

		move (direction) from () with (new-distance) :
			new-cell : cell going (direction) from ()
			new-cell [distance] : new-distance
			move outwards from the (new-cell)

		cell going (direction) from () :
			choose from
				[direction = RIGHT] do [right from the ()]
				[direction = LEFT]  do [left from the ()]
				[direction = UP]    do [up from the ()]
				[direction = DOWN]  do [down from the ()]

find the middle :
	middle-x : convert (num-cols ÷ 2) to integer + 1
	middle-y : convert (num-rows ÷ 2) to integer + 1
	{ middle-x, middle-y }

on standard (black) paper
	draw together
		prepare the maze grid
		make the sidewinder maze
	wait 1 sec
	draw together
		(blue) dot in the (cell at (start))
		(orange) dot in the (cell at (finish))
	solve the maze from (start) to (finish)

prepare the maze grid :
	for (num-rows) rows (this-row) [append {} to (the-maze)] and (num-cols) columns (this-col)
		cell : create a maze cell at (this-row) and (this-col)
		append (cell) to (the-maze [this-row])
		draw the (cell)

show the maze :
	for (num-rows) rows (this-row) and (num-cols) columns (this-col)
		cell : cell at { this-col, this-row }
		draw the exits on the (cell)

make the sidewinder maze :
	deal with all rows except the bottom
	deal with the bottom row
	show the maze

deal with all rows except the bottom :
	for each (row) from 1 to (num-rows - 1)
		deal with all columns in the (row) except the right
		deal with the right cell in the (row)

deal with all columns in the (row) except the right :
	start-run : 1
	for each (col) from 1 to (num-cols - 1)
		if (heads) [
			remove the right wall in the (cell at { col, row })
		] otherwise [
			gap : choose from (start-run) to (col)
			remove the bottom wall in the (cell at { gap, row })
			start-run : col + 1
		]

deal with the right cell in the (row) :
	remove the bottom wall in the (cell at { num-cols, row })

deal with the bottom row : 
	for each (col) from 1 to (num-cols - 1)
		remove the right wall in the (cell at { col, num-rows })

cell at (position) :
	Return the cell object at "position".
	the-row : the-maze [position [2]]
	the-row [position [1]]

choose from (start) to (finish) :
	(random (1 + finish - start)) + start - 1

solve the maze from (start) to (finish) :
	beginning : cell at (finish) ; going backwards
	beginning [distance] : 0
	move outwards from the (beginning)
	plot the solution

plot the solution :
	start-cell : cell at (start)
	go closer than (start-cell [distance]) from (start-cell)

go closer than (distance) from (cell) :
	if [cell ≠ cell at (start)]
		wait 0.25 sec
		(green) dot in the (cell)
	if [distance > 1] 
		distance : distance - 1
		choose from
			[all of {
				[can move right from the (cell)], 
				[(right from the (cell)) is (distance) away]
			}] do
				go closer than (distance) from (right from the (cell))
			[all of {
				[can move left from the (cell)], 
				[(left from the (cell)) is (distance) away]
			}] do
				go closer than (distance) from (left from the (cell))
			[all of {
				[can move down from the (cell)], 
				[(down from the (cell)) is (distance) away]
			}] do
				go closer than (distance) from (down from the (cell))
			[all of {
				[can move up from the (cell)], 
				[(up from the (cell)) is (distance) away]
			}] do
				go closer than (distance) from (up from the (cell))
